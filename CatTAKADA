-- Generated using RoadToGlory's Converter v1.1 (RoadToGlory#9879)

-- Instances:

local Converted = {
	["_main"] = Instance.new("ScreenGui");
	["_move"] = Instance.new("LocalScript");
	["_title"] = Instance.new("TextLabel");
	["_Esp"] = Instance.new("TextButton");
	["_EspONOFF"] = Instance.new("LocalScript");
	["_UIStroke"] = Instance.new("UIStroke");
	["_Aimbot"] = Instance.new("TextButton");
	["_AimbotONOFF"] = Instance.new("LocalScript");
	["_UIStroke1"] = Instance.new("UIStroke");
	["_Fullbright"] = Instance.new("TextButton");
	["_FullbrightONOFF"] = Instance.new("LocalScript");
	["_UIStroke2"] = Instance.new("UIStroke");
	["_Distance"] = Instance.new("TextButton");
	["_DistanceONOFF"] = Instance.new("LocalScript");
	["_UIStroke3"] = Instance.new("UIStroke");
	["_TpWalk"] = Instance.new("TextButton");
	["_tpwalkONOFF"] = Instance.new("LocalScript");
	["_UIStroke4"] = Instance.new("UIStroke");
	["_have"] = Instance.new("Frame");
	["_UIStroke5"] = Instance.new("UIStroke");
}

-- Properties:

Converted["_main"].Name = "main"
Converted["_main"].Parent = game:GetService("CoreGui")

Converted["_title"].Font = Enum.Font.Code
Converted["_title"].Text = "CatTAKADA"
Converted["_title"].TextColor3 = Color3.fromRGB(0, 255, 255)
Converted["_title"].TextSize = 30
Converted["_title"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_title"].BackgroundTransparency = 1
Converted["_title"].BorderColor3 = Color3.fromRGB(170.0000050663948, 0, 255)
Converted["_title"].BorderSizePixel = 0
Converted["_title"].Position = UDim2.new(0.389062494, 0, 0.304629624, 0)
Converted["_title"].Size = UDim2.new(0.221874982, 0, 0.0648148134, 0)
Converted["_title"].ZIndex = 2
Converted["_title"].Name = "title"
Converted["_title"].Parent = Converted["_main"]

Converted["_Esp"].Font = Enum.Font.SourceSans
Converted["_Esp"].Text = "Esp"
Converted["_Esp"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_Esp"].TextSize = 30
Converted["_Esp"].BackgroundColor3 = Color3.fromRGB(0, 110.00000104308128, 165.00000536441803)
Converted["_Esp"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Esp"].BorderSizePixel = 0
Converted["_Esp"].Position = UDim2.new(0.389062494, 0, 0.36944443, 0)
Converted["_Esp"].Size = UDim2.new(0.0442708321, 0, 0.0435185172, 0)
Converted["_Esp"].ZIndex = 2
Converted["_Esp"].Name = "Esp"
Converted["_Esp"].Parent = Converted["_main"]

Converted["_UIStroke"].Parent = Converted["_Esp"]

Converted["_Aimbot"].Font = Enum.Font.SourceSans
Converted["_Aimbot"].Text = "Aimbot"
Converted["_Aimbot"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_Aimbot"].TextSize = 30
Converted["_Aimbot"].BackgroundColor3 = Color3.fromRGB(0, 110.00000104308128, 165.00000536441803)
Converted["_Aimbot"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Aimbot"].BorderSizePixel = 0
Converted["_Aimbot"].Position = UDim2.new(0.436979175, 0, 0.36944443, 0)
Converted["_Aimbot"].Size = UDim2.new(0.0442708321, 0, 0.0435185172, 0)
Converted["_Aimbot"].ZIndex = 2
Converted["_Aimbot"].Name = "Aimbot"
Converted["_Aimbot"].Parent = Converted["_main"]

Converted["_UIStroke1"].Parent = Converted["_Aimbot"]

Converted["_Fullbright"].Font = Enum.Font.SourceSans
Converted["_Fullbright"].Text = "Fullbright"
Converted["_Fullbright"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_Fullbright"].TextSize = 30
Converted["_Fullbright"].BackgroundColor3 = Color3.fromRGB(0, 110.00000104308128, 165.00000536441803)
Converted["_Fullbright"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Fullbright"].BorderSizePixel = 0
Converted["_Fullbright"].Position = UDim2.new(0.486979157, 0, 0.36944443, 0)
Converted["_Fullbright"].Size = UDim2.new(0.0572916679, 0, 0.0435185172, 0)
Converted["_Fullbright"].ZIndex = 2
Converted["_Fullbright"].Name = "Fullbright"
Converted["_Fullbright"].Parent = Converted["_main"]

Converted["_UIStroke2"].Parent = Converted["_Fullbright"]

Converted["_Distance"].Font = Enum.Font.SourceSans
Converted["_Distance"].Text = "Distance"
Converted["_Distance"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_Distance"].TextSize = 30
Converted["_Distance"].BackgroundColor3 = Color3.fromRGB(0, 110.00000104308128, 165.00000536441803)
Converted["_Distance"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Distance"].BorderSizePixel = 0
Converted["_Distance"].Position = UDim2.new(0.389062494, 0, 0.424074054, 0)
Converted["_Distance"].Size = UDim2.new(0.0541666709, 0, 0.0435185172, 0)
Converted["_Distance"].ZIndex = 2
Converted["_Distance"].Name = "Distance"
Converted["_Distance"].Parent = Converted["_main"]

Converted["_UIStroke3"].Parent = Converted["_Distance"]

Converted["_TpWalk"].Font = Enum.Font.SourceSans
Converted["_TpWalk"].Text = "TpWalk"
Converted["_TpWalk"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_TpWalk"].TextSize = 30
Converted["_TpWalk"].BackgroundColor3 = Color3.fromRGB(0, 110.00000104308128, 165.00000536441803)
Converted["_TpWalk"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TpWalk"].BorderSizePixel = 0
Converted["_TpWalk"].Position = UDim2.new(0.548437476, 0, 0.36944443, 0)
Converted["_TpWalk"].Size = UDim2.new(0.0572916679, 0, 0.0435185172, 0)
Converted["_TpWalk"].ZIndex = 2
Converted["_TpWalk"].Name = "TpWalk"
Converted["_TpWalk"].Parent = Converted["_main"]

Converted["_UIStroke4"].Parent = Converted["_TpWalk"]

Converted["_have"].BackgroundColor3 = Color3.fromRGB(67.00000360608101, 67.00000360608101, 67.00000360608101)
Converted["_have"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_have"].BorderSizePixel = 0
Converted["_have"].Position = UDim2.new(0.389062494, 0, 0.3694444, 0)
Converted["_have"].Size = UDim2.new(0.222000003, 0, 0.261000007, 0)
Converted["_have"].Name = "have"
Converted["_have"].Parent = Converted["_main"]

Converted["_UIStroke5"].Color = Color3.fromRGB(0, 170.0000050663948, 255)
Converted["_UIStroke5"].Parent = Converted["_have"]

-- Fake Module Scripts:

local fake_module_scripts = {}


-- Fake Local Scripts:

local function FIYID_fake_script() -- Fake Script: StarterGui.main.move
    local script = Instance.new("LocalScript")
    script.Name = "move"
    script.Parent = Converted["_main"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	--------------------------------------------------------------------------------
	-- TweenService、UserInputService の取得
	--------------------------------------------------------------------------------
	local TweenService = game:GetService("TweenService")
	local UserInputService = game:GetService("UserInputService")
	
	--------------------------------------------------------------------------------
	-- Gui の参照
	--------------------------------------------------------------------------------
	local screenGui = script.Parent               -- このスクリプトが ScreenGui 直下にある想定
	local have = screenGui:WaitForChild("have")   -- ドラッグ用フレーム
	
	--------------------------------------------------------------------------------
	-- ドラッグ関連の変数
	--------------------------------------------------------------------------------
	local dragging = false
	local dragStart
	local initialPositions = {}
	
	--------------------------------------------------------------------------------
	-- 表示/非表示関連の変数
	--------------------------------------------------------------------------------
	local isVisible = true
	local fadeDuration = 0.25  -- 表示・非表示のアニメーション所要時間
	
	--------------------------------------------------------------------------------
	-- 「ドラッグ移動」をアニメーションさせる関数
	--------------------------------------------------------------------------------
	local function tweenMove(guiObject, newPos, duration)
		local tweenInfo = TweenInfo.new(
			duration,                       -- 時間
			Enum.EasingStyle.Linear,        -- アニメの種類
			Enum.EasingDirection.Out        -- 終わり際をゆっくり
		)
		local tween = TweenService:Create(guiObject, tweenInfo, {
			Position = newPos
		})
		tween:Play()
	end
	
	--------------------------------------------------------------------------------
	-- ドラッグ中に全ての GUI を動かす関数
	--------------------------------------------------------------------------------
	local function moveAllGUIs(input)
		local delta = input.Position - dragStart
		for guiObject, storedPos in pairs(initialPositions) do
			local newX = storedPos.X + delta.X
			local newY = storedPos.Y + delta.Y
			local newPos = UDim2.fromOffset(newX, newY)
	
			-- 滑らかに動かしたい場合は tweenMove
			tweenMove(guiObject, newPos, 0.1)
		end
	end
	
	--------------------------------------------------------------------------------
	-- GUI をフェードさせながら表示／非表示を切り替えるための処理
	--------------------------------------------------------------------------------
	
	-- 子要素を含めてフェードしたい場合は再帰的に呼ぶ
	local function tweenFade(guiObject, finalTransparency, duration)
		--------------------------------------------------------------------------------
		-- ■ TextLabel / TextButton：テキスト透明度のみを変更し、BackgroundTransparency はいじらない
		--------------------------------------------------------------------------------
		if guiObject:IsA("TextLabel") or guiObject:IsA("TextButton") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				TextTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
	
			--------------------------------------------------------------------------------
			-- ■ Frame / ScrollingFrame：背景だけフェードする（必要なら）
			--------------------------------------------------------------------------------
		elseif guiObject:IsA("Frame") or guiObject:IsA("ScrollingFrame") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				BackgroundTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
	
			--------------------------------------------------------------------------------
			-- ■ ImageLabel / ImageButton：画像と背景をフェードする（必要なら）
			--------------------------------------------------------------------------------
		elseif guiObject:IsA("ImageLabel") or guiObject:IsA("ImageButton") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				ImageTransparency = finalTransparency,
				BackgroundTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
		end
	
		--------------------------------------------------------------------------------
		-- 子要素を再帰的に処理する
		--------------------------------------------------------------------------------
		for _, child in ipairs(guiObject:GetChildren()) do
			if child:IsA("GuiObject") then
				tweenFade(child, finalTransparency, duration)
			end
		end
	end
	
	-- GUI 全体を「表示 → 非表示（フェードアウト）」または「非表示 → 表示（フェードイン）」へ切り替える関数
	local function toggleVisibility()
		isVisible = not isVisible  -- true <-> false の切り替え
	
		if isVisible then
			-- まず Visible = true にしてからフェードイン
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					child.Visible = true
					tweenFade(child, 0, fadeDuration) -- 0 = 不透明にする
				end
			end
		else
			-- フェードアウト完了後に Visible = false
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					tweenFade(child, 1, fadeDuration) -- 1 = 完全透明
	
					-- Tween 完了後に Visible = false
					local tweenInfo = TweenInfo.new(fadeDuration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
					local tween = TweenService:Create(child, tweenInfo, {})
					tween:Play()
					tween.Completed:Connect(function()
						child.Visible = false
					end)
				end
			end
		end
	end
	
	--------------------------------------------------------------------------------
	-- have フレームをクリックしたときの処理（ドラッグ開始）
	--------------------------------------------------------------------------------
	have.InputBegan:Connect(function(input)
		-- 左クリック（またはタッチ）の開始を検知したら
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
	
			-- ScreenGui 配下のすべての GUIObject の座標を保存
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					initialPositions[child] = child.AbsolutePosition
				end
			end
	
			-- マウスを離したかどうかチェック
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	--------------------------------------------------------------------------------
	-- マウス移動中の処理 (ドラッグ中なら全 GUI を移動)
	--------------------------------------------------------------------------------
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			moveAllGUIs(input)
		end
	end)
	
	--------------------------------------------------------------------------------
	-- 右シフト（RightShift）で全てを表示/非表示にする処理
	--------------------------------------------------------------------------------
	UserInputService.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Keyboard 
			and input.KeyCode == Enum.KeyCode.RightShift 
		then
			toggleVisibility()
		end
	end)
	
end
local function AXBCF_fake_script() -- Fake Script: StarterGui.main.Esp.EspONOFF
    local script = Instance.new("LocalScript")
    script.Name = "EspONOFF"
    script.Parent = Converted["_Esp"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	--[[ 
	    このスクリプトを例として、StarterPlayerScripts に配置していると想定します。
	    ただし、TextButton（button）は通常はScreenGui > Frameの子などにあるので、
	    親/パスを適切に指定する必要があります。下記例では仮に
	    "StarterGui > ScreenGui > Frame > TextButton" を参照している想定です。
	    
	    button = script.Parent だと、同じ階層に置いている場合のみ動作します。
	    必要に応じて、buttonへの参照方法を修正してください。
	]]
	
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	local Camera = workspace.CurrentCamera
	
	------------------------------------------------
	-- ▼ ここからボタンの取得と色切り替え
	------------------------------------------------
	-- ボタンを取得（たとえば、ScreenGuiなどにある TextButton）
	local button = script.Parent  -- 必要に応じてパスを変更してください
	
	-- 元のテキスト色（最初に設定されている色を覚えておく）
	local originalColor = button.TextColor3
	-- 緑色
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 緑状態かどうか
	local isGreen = false
	
	-- 「枠表示（ESP）が有効かどうか」を示すフラグ
	local isBoxOn = false
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		-- 緑/元の色を切り替え
		isGreen = not isGreen
		if isGreen then
			button.TextColor3 = greenColor
			isBoxOn = true   -- 緑色になったら枠描画オン
		else
			button.TextColor3 = originalColor
			isBoxOn = false  -- 元の色に戻ったら枠描画オフ
		end
	end)
	
	------------------------------------------------
	-- ▼ ここからESP(枠表示)関連の処理
	------------------------------------------------
	
	-- Player -> { Outline = Drawingオブジェクト, Box = Drawingオブジェクト }
	local Boxes = {}
	
	-- 枠（Box）を作成する
	local function createBoxForPlayer(player)
		-- 自分自身のキャラクターには表示しない
		if player == LocalPlayer then return end
		if Boxes[player] then return end
	
		-- 黒の外枠
		local outlineSquare = Drawing.new("Square")
		outlineSquare.Visible = false
		outlineSquare.Thickness = 2
		outlineSquare.Filled = false
		outlineSquare.Color = Color3.fromRGB(0, 0, 0) -- 黒
	
		-- 水色の内枠
		local boxSquare = Drawing.new("Square")
		boxSquare.Visible = false
		boxSquare.Thickness = 1
		boxSquare.Filled = false
		boxSquare.Color = Color3.fromRGB(0,255,255) -- 水色
	
		Boxes[player] = {
			Outline = outlineSquare,
			Box = boxSquare,
		}
	end
	
	-- 枠（Box）を削除する
	local function removeBoxForPlayer(player)
		if Boxes[player] then
			Boxes[player].Outline:Remove()
			Boxes[player].Box:Remove()
			Boxes[player] = nil
		end
	end
	
	-- 全ての枠を非表示にする（オフ時用）
	local function hideAllBoxes()
		for player, boxData in pairs(Boxes) do
			boxData.Outline.Visible = false
			boxData.Box.Visible = false
		end
	end
	
	-- 毎フレーム呼び出して、枠を更新（位置や大きさ）する
	local function updateBoxes()
		for player, boxData in pairs(Boxes) do
			local character = player.Character
			if character and character:FindFirstChild("HumanoidRootPart") then
				local hrp = character.HumanoidRootPart
				local rootPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
	
				if onScreen then
					-- ざっくりと上下をとる
					local heightOffset = 3
					local topPos = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, heightOffset, 0))
					local bottomPos = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, heightOffset, 0))
	
					local boxHeight = math.abs(topPos.Y - bottomPos.Y)
					local boxWidth = boxHeight / 2
	
					local xPos = rootPos.X - boxWidth/2
					local yPos = rootPos.Y - boxHeight/2
	
					-- 外枠
					boxData.Outline.Size = Vector2.new(boxWidth, boxHeight)
					boxData.Outline.Position = Vector2.new(xPos, yPos)
					boxData.Outline.Visible = true
	
					-- 内枠
					boxData.Box.Size = Vector2.new(boxWidth, boxHeight)
					boxData.Box.Position = Vector2.new(xPos, yPos)
					boxData.Box.Visible = true
				else
					-- 画面外なら非表示
					boxData.Outline.Visible = false
					boxData.Box.Visible = false
				end
			else
				-- キャラクターがない/HRPがない場合も非表示
				boxData.Outline.Visible = false
				boxData.Box.Visible = false
			end
		end
	end
	
	-- プレイヤーの参加・退出に合わせてBox生成/削除
	local PlayersService = game:GetService("Players")
	for _, player in ipairs(PlayersService:GetPlayers()) do
		createBoxForPlayer(player)
	end
	PlayersService.PlayerAdded:Connect(createBoxForPlayer)
	PlayersService.PlayerRemoving:Connect(removeBoxForPlayer)
	
	-- 毎フレーム、枠描画を更新
	RunService.RenderStepped:Connect(function()
		if isBoxOn then
			updateBoxes()
		else
			-- オフの間は枠を表示しない
			hideAllBoxes()
		end
	end)
	
end
local function LWSN_fake_script() -- Fake Script: StarterGui.main.Aimbot.AimbotONOFF
    local script = Instance.new("LocalScript")
    script.Name = "AimbotONOFF"
    script.Parent = Converted["_Aimbot"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextButtonを取得
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態を管理するフラグ
	local isGreen = false
	
	-- 2つ目のスクリプトで使用する変数・接続を格納するテーブル
	local connections = {}
	
	-- サービスの取得
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	
	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera
	
	-- Drawingライブラリを使用して線を作成
	local line = Drawing.new("Line")
	line.Color = Color3.new(1, 0, 0)
	line.Thickness = 2
	line.Transparency = 1
	
	-- 右クリックのフラグ
	local isRightClickDown = false
	
	-- 現在のターゲットプレイヤー
	local currentTargetPlayer = nil
	
	-- スムーズネスの設定を調整してaim強度を高める（値を小さくするとより強くなります）
	local smoothness = 3  -- これを小さくするほど強いaimになります
	
	-- 最大距離の設定（メートル単位）
	local maxDistance = 350
	
	-- 2つ目のスクリプトの処理開始時に呼ばれる関数
	local function startSecondScript()
		-- 右クリックの押下・解放を検出
		local inputBeganConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton2 then
				isRightClickDown = true
			end
		end)
		table.insert(connections, inputBeganConn)
	
		local inputEndedConn = UserInputService.InputEnded:Connect(function(input, gameProcessed)
			if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton2 then
				isRightClickDown = false
			end
		end)
		table.insert(connections, inputEndedConn)
	
		-- RenderSteppedで毎フレーム更新
		local renderConn = RunService.RenderStepped:Connect(function()
			local mousePos = UserInputService:GetMouseLocation()
	
			-- 右クリック中でなければターゲット探索を行う
			if not isRightClickDown then
				local nearestPlayer = nil
				local nearestDist = math.huge
	
				-- 最も近いプレイヤーを探す処理
				for _, otherPlayer in ipairs(Players:GetPlayers()) do
					if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Head") then
						local head = otherPlayer.Character.Head
						local headScreenPos, onScreen = camera:WorldToViewportPoint(head.Position)
						local distance = (camera.CFrame.Position - head.Position).Magnitude
						-- プレイヤーが画面内にいて、250m以内の場合のみ考慮
						if onScreen and distance <= maxDistance then
							local headVec2 = Vector2.new(headScreenPos.X, headScreenPos.Y)
							local dist = (headVec2 - mousePos).Magnitude
							if dist < nearestDist then
								nearestDist = dist
								nearestPlayer = otherPlayer
							end
						end
					end
				end
	
				-- 新しいターゲットが見つかった場合のみ更新
				if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("Head") then
					local head = nearestPlayer.Character.Head
					local headScreenPos, onScreen = camera:WorldToViewportPoint(head.Position)
					local distance = (camera.CFrame.Position - head.Position).Magnitude
					-- プレイヤーが画面内にいて、250m以内の場合のみ線を表示
					if onScreen and distance <= maxDistance then
						currentTargetPlayer = nearestPlayer
					else
						currentTargetPlayer = nil
					end
				else
					currentTargetPlayer = nil
				end
			end
	
			-- 現在のターゲットプレイヤーに基づいて線の更新処理を行う
			if currentTargetPlayer and currentTargetPlayer.Character and currentTargetPlayer.Character:FindFirstChild("Head") then
				local head = currentTargetPlayer.Character.Head
				local headScreenPos, onScreen = camera:WorldToViewportPoint(head.Position)
				local distance = (camera.CFrame.Position - head.Position).Magnitude
				-- プレイヤーが画面内にいて、250m以内の場合のみ線を表示
				if onScreen and distance <= maxDistance then
					line.Visible = true
					line.From = mousePos
					line.To = Vector2.new(headScreenPos.X, headScreenPos.Y)
				else
					line.Visible = false
				end
			else
				line.Visible = false
			end
	
			-- 右クリック押下中でターゲットが存在する場合、マウスをスムーズに移動
			if isRightClickDown and currentTargetPlayer 
				and currentTargetPlayer.Character 
				and currentTargetPlayer.Character:FindFirstChild("Head") then
	
				local targetHead = currentTargetPlayer.Character.Head
				local headScreenPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
				local distance = (camera.CFrame.Position - targetHead.Position).Magnitude
				if onScreen and distance <= maxDistance then
					local targetScreenPos = Vector2.new(headScreenPos.X, headScreenPos.Y)
					-- 現在のマウス位置を取得
					local currentMousePos = UserInputService:GetMouseLocation()
					-- 移動量を計算し、aim強度を反映
					local deltaX = (targetScreenPos.X - currentMousePos.X) / smoothness
					local deltaY = (targetScreenPos.Y - currentMousePos.Y) / smoothness
					-- マウスを相対移動
					mousemoverel(deltaX, deltaY)
				end
			end
		end)
		table.insert(connections, renderConn)
	end
	
	-- 2つ目のスクリプトの処理停止時に呼ばれる関数
	local function stopSecondScript()
		-- 確立された全ての接続を解除
		for _, conn in ipairs(connections) do
			if conn.Connected then
				conn:Disconnect()
			end
		end
		connections = {}  -- 接続リストをリセット
	
		-- 必要に応じてフラグや線の表示をリセット
		isRightClickDown = false
		currentTargetPlayer = nil
		line.Visible = false
	end
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			-- 緑色なら元の色に戻し、2つ目のスクリプトを停止
			button.TextColor3 = originalColor
			stopSecondScript()
		else
			-- 緑色でない場合は緑色にし、2つ目のスクリプトを開始
			button.TextColor3 = greenColor
			startSecondScript()
		end
		-- 状態を反転
		isGreen = not isGreen
	end)
end
local function EBBL_fake_script() -- Fake Script: StarterGui.main.Fullbright.FullbrightONOFF
    local script = Instance.new("LocalScript")
    script.Name = "FullbrightONOFF"
    script.Parent = Converted["_Fullbright"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextButtonを取得
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- LightingサービスとRunServiceを取得
	local lighting = game:GetService("Lighting")
	local RunService = game:GetService("RunService")
	
	-- 照明調整を管理するフラグ
	local lightingEnabled = false
	
	-- RenderSteppedイベントの接続を保持する変数
	local connection
	
	-- 照明調整関数
	local function updateLighting()
		lighting.Brightness = 5 -- 明るさのレベルを調整 (通常は1がデフォルト)
		lighting.Ambient = Color3.new(1, 1, 1) -- 環境光の色を白にする
		lighting.OutdoorAmbient = Color3.new(1, 1, 1) -- 屋外環境光の色を白にする
		lighting.GlobalShadows = false -- 影を無効にする
		-- 必要に応じて他の設定も追加
	end
	
	-- 照明設定を元に戻す関数
	local function resetLighting()
		lighting.Brightness = 2 -- デフォルトの明るさに戻す（例）
		lighting.Ambient = Color3.new(0.5, 0.5, 0.5) -- デフォルトの環境光色
		lighting.OutdoorAmbient = Color3.new(0.3, 0.3, 0.3) -- デフォルトの屋外環境光色
		lighting.GlobalShadows = true -- 影を有効にする
		-- 必要に応じて他の設定もデフォルトに戻す
	end
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if lightingEnabled then
			-- 照明を無効にして元の色に戻す
			button.TextColor3 = originalColor
			if connection then
				connection:Disconnect()
				connection = nil
			end
			resetLighting()
		else
			-- 照明を有効にして緑色にする
			button.TextColor3 = greenColor
			connection = RunService.RenderStepped:Connect(updateLighting)
			updateLighting() -- 初回実行
		end
		-- 照明の状態を反転
		lightingEnabled = not lightingEnabled
	end)
	
end
local function HKBQLT_fake_script() -- Fake Script: StarterGui.main.Distance.DistanceONOFF
    local script = Instance.new("LocalScript")
    script.Name = "DistanceONOFF"
    script.Parent = Converted["_Distance"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- // LocalScript in StarterPlayerScripts
	
	---------------------------------------------
	-- ▼ 1) ボタンの ON/OFF トグル管理
	---------------------------------------------
	local button = script.Parent  -- このスクリプトの親がTextButtonの場合
	
	-- ボタンの元のテキスト色を取得
	local originalColor = button.TextColor3
	-- 緑色
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- ボタンの色トグル状態
	local isGreen = false
	-- 距離表示を行うかどうかのフラグ
	local isDistanceOn = false
	
	-- ボタンクリック時
	button.MouseButton1Click:Connect(function()
		if isGreen then
			-- 緑だった場合、元の色に戻して距離表示をOFF
			button.TextColor3 = originalColor
			isDistanceOn = false
		else
			-- 緑以外の場合、緑にして距離表示をON
			button.TextColor3 = greenColor
			isDistanceOn = true
		end
		-- 状態反転
		isGreen = not isGreen
	end)
	
	
	---------------------------------------------
	-- ▼ 2) 距離表示のメイン処理 (Drawing API)
	---------------------------------------------
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	local Camera = workspace.CurrentCamera
	
	-- 各プレイヤーのテキストオブジェクトを管理
	local Distances = {}
	
	-- テキストを作成する関数
	local function createDistanceTextForPlayer(player)
		-- 自キャラは除外
		if player == LocalPlayer then return end
		if Distances[player] then return end
	
		local textObj = Drawing.new("Text")
		textObj.Visible = false
		textObj.Color = Color3.fromRGB(0, 255, 255)
		textObj.Outline = true
		textObj.OutlineColor = Color3.fromRGB(0, 0, 0)
		textObj.Center = true
		textObj.Size = 16
	
		Distances[player] = textObj
	end
	
	-- テキストを削除する関数
	local function removeDistanceTextForPlayer(player)
		if Distances[player] then
			Distances[player]:Remove()
			Distances[player] = nil
		end
	end
	
	-- プレイヤー追加/削除イベント
	local function onPlayerAdded(player)
		createDistanceTextForPlayer(player)
	end
	local function onPlayerRemoving(player)
		removeDistanceTextForPlayer(player)
	end
	
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	-- 既存プレイヤーにも適用
	for _, p in ipairs(Players:GetPlayers()) do
		onPlayerAdded(p)
	end
	
	---------------------------------------------
	-- ▼ 毎フレームで距離テキストを更新
	---------------------------------------------
	RunService.RenderStepped:Connect(function()
		-- もしOFFなら、まとめて非表示にする
		if not isDistanceOn then
			for _, textObj in pairs(Distances) do
				textObj.Visible = false
			end
			return
		end
	
		-- 距離表示がONの場合のみ処理
		local localChar = LocalPlayer.Character
		local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")
		if not localHRP then
			-- 自分のキャラがまだない/リスポーン中は、全て非表示
			for _, textObj in pairs(Distances) do
				textObj.Visible = false
			end
			return
		end
	
		for player, textObj in pairs(Distances) do
			local char = player.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			if hrp then
				-- 距離を計算 (四捨五入して整数に)
				local distance = (localHRP.Position - hrp.Position).Magnitude
				distance = math.floor(distance + 0.5)
	
				textObj.Text = "[" .. distance .. "]"
	
				-- "足元" を仮に3スタッド下げた位置 (R6想定)
				local footPos3D = hrp.Position - Vector3.new(0, 3, 0)
	
				-- 2D座標に変換
				local screenPos, onScreen = Camera:WorldToViewportPoint(footPos3D)
				if onScreen then
					-- 画面内なら可視化
					textObj.Position = Vector2.new(screenPos.X, screenPos.Y)
					textObj.Visible = true
				else
					textObj.Visible = false
				end
			else
				textObj.Visible = false
			end
		end
	end)
	
end
local function OGDJ_fake_script() -- Fake Script: StarterGui.main.TpWalk.tpwalkONOFF
    local script = Instance.new("LocalScript")
    script.Name = "tpwalkONOFF"
    script.Parent = Converted["_TpWalk"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- 必要なサービスの取得
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local RunService = game:GetService("RunService")
	
	local LocalPlayer = Players.LocalPlayer
	
	-- TextButtonの取得（このスクリプトはボタンの子として配置）
	local button = script:FindFirstChildWhichIsA("TextButton") or script.Parent
	
	-- ボタンの色設定
	local originalColor = button.TextColor3
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態と機能のオンオフを管理するフラグ
	local isGreen = false
	local featureEnabled = false
	
	-- キャラクターと移動に関する設定
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	local moveIncrement = 0.7
	
	-- 現在の移動方向を保持するテーブル
	local moveDirection = {
		forward = false,
		backward = false,
		left = false,
		right = false
	}
	
	-- キー入力が始まったときの処理
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		local key = input.KeyCode
		if key == Enum.KeyCode.W or key == Enum.KeyCode.Up then
			moveDirection.forward = true
		elseif key == Enum.KeyCode.S or key == Enum.KeyCode.Down then
			moveDirection.backward = true
		elseif key == Enum.KeyCode.A or key == Enum.KeyCode.Left then
			moveDirection.left = true
		elseif key == Enum.KeyCode.D or key == Enum.KeyCode.Right then
			moveDirection.right = true
		end
	end)
	
	-- キー入力が終了したときの処理
	UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		local key = input.KeyCode
		if key == Enum.KeyCode.W or key == Enum.KeyCode.Up then
			moveDirection.forward = false
		elseif key == Enum.KeyCode.S or key == Enum.KeyCode.Down then
			moveDirection.backward = false
		elseif key == Enum.KeyCode.A or key == Enum.KeyCode.Left then
			moveDirection.left = false
		elseif key == Enum.KeyCode.D or key == Enum.KeyCode.Right then
			moveDirection.right = false
		end
	end)
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			featureEnabled = false
			print("TPWalk Disabled")
		else
			button.TextColor3 = greenColor
			featureEnabled = true
			print("TPWalk Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- 毎フレームの処理
	RunService.RenderStepped:Connect(function()
		if featureEnabled then
			-- キャラクターやHumanoidRootPartが無効な場合は再取得
			if not character or not character.Parent then
				character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
				humanoidRootPart = character:WaitForChild("HumanoidRootPart")
			end
	
			local moveVector = Vector3.new(0, 0, 0)
			local cf = humanoidRootPart.CFrame
			local forwardVector = cf.LookVector
			local rightVector = cf.RightVector
	
			if moveDirection.forward then
				moveVector = moveVector + forwardVector
			end
			if moveDirection.backward then
				moveVector = moveVector - forwardVector
			end
			if moveDirection.left then
				moveVector = moveVector - rightVector
			end
			if moveDirection.right then
				moveVector = moveVector + rightVector
			end
	
			if moveVector.Magnitude > 0 then
				moveVector = moveVector.Unit * moveIncrement
				local currentCFrame = humanoidRootPart.CFrame
				local newCFrame = currentCFrame + moveVector
				humanoidRootPart.CFrame = newCFrame
			end
		end
	end)
	
end

coroutine.wrap(FIYID_fake_script)()
coroutine.wrap(AXBCF_fake_script)()
coroutine.wrap(LWSN_fake_script)()
coroutine.wrap(EBBL_fake_script)()
coroutine.wrap(HKBQLT_fake_script)()
coroutine.wrap(OGDJ_fake_script)()
